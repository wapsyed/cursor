---
title: "CursoR - Introdução à análise de dados no R"
author: 'Autor: Wasim Aluísio Prates Syed (@wasimvacinas)'
date: "`r Sys.Date()`"
output:
  html_document:
    theme: simplex
    toc: yes
    toc_float:
      collapsed: true
---

> **Nova versão otimizada para leitura aqui:** <https://wapsyed.github.io/cursor/>

# Sobre o curso

**\
Ministrantes:** 
- Wasim Aluísio Prates Syed: Farmacêutico pela FCFRP-USP, doutorando em biotecnologia pelo ICB/IPT/Butantan, e divulgador científico pela UPVacina (IEARP-USP) e Projeto Halo (ONU).
- Dennyson Leandro Mathias da Fonseca: Biomédico e doutorando no programa de Interunidades em Bioinformática da Universidade de São Paulo (USP). Atuou como pesquisador convidado no Berlin Institute of Health (BIH), Universitätsmedizin Charité, Alemanha.


**Descrição do curso:**

O aprendizado de uma das linguagens de programação e análise de dados mais populares e acessíveis é fundamental para desenvolvimento de projetos de bioinformática. Esta linguagem é amplamente utilizada por cientistas devido à sua variedade de ferramentas para análise de dados em ciências biológicas e da saúde. Por este motivo, desenvolvemos este curso para aqueles que não têm formação em áreas de exatas, como TI e ciência da computação, e desejam se aprofundar nas análises de bioinformática. Com uma abordagem prática e interativa, os participantes explorarão conceitos e ferramentas para realizar análises de dados de forma simples e intuitiva. Além disso, desenvolverão um projeto simples de exploração de dados reais de expressão gênica.

**Programação e conteúdo**

Os participantes terão uma aula introdutória à ciência de dados e fundamentos da manipulação de dados no R e visualização de dados com o ggplot, no ambiente do RStudio. Em seguida, os participantes terão um tempo para praticar e desenvolver as análises com 5 países de escolha, e no final deverão criar um poster com os gráficos produzidos.

-   **Introdução ao R:** Explicaremos por que o R é importante para cientistas e profissionais da saúde.

-   **Fundamentos da Programação em R:** Abordaremos conceitos como funções, pacotes, variáveis e estruturas de dados, como data frames, listas e matrizes.

-   **Manipulação e Visualização de Dados:** Exploraremos técnicas para importar, limpar, filtrar e visualizar dados usando pacotes do Tidyverse, como dplyr e ggplot2.

-   **Análise Exploratória de Dados:** Realizaremos análises exploratórias de dados, incluindo estatísticas descritivas, gráficos e interpretação de resultados. Aplicaremos os conhecimentos adquiridos em um projeto prático com dados reais de saúde, incluindo análise de vacinação e indicadores de saúde pública.

**Como será o projeto**:

O projeto consistirá na geração de pelo menos 5 gráficos acompanhados de discussões pertinentes, e terão direito a um certificado à parte. Para isso, durante o curso, serão apresentadas perguntas que poderão ser utilizadas para desenvolver o projeto. O objetivo principal é explorar os diversos tipos de gráficos disponíveis, formular perguntas pertinentes e explicar os padrões e comportamentos observados nos dados analisados.

Os participantes terão 1 mês para desenvolver o projeto, e poderão tirar dúvidas no grupo de WhatsApp e marcar uma mentoria individual, se necessário.

> **Quer saber mais sobre o curso e outros materiais que estamos desenvolvendo?**
>
> Siga-nos no Instagram ([\@vidyadados](https://www.instagram.com/vidyadados/)) e acesse nosso [site](https://sites.google.com/view/cursocursor/home)!

# Como usar este tutorial?

**RStudio no navegador:**

**O R e o RStudio baixado para o desktop pode não ser a melhor opção para todos**. Por isso, uma opção viável que encontramos seria usar o R na versão da nuvem, disponível no navegador. Para testar, entre em [posit.cloud](posit.cloud), crie uma conta, acesse seu login, clique em "New Project" e em "New Project from Git Repository" e cole o link: <https://github.com/wapsyed/cursor.git.> Isso abrirá o R studio no próprio navegador.

**Para rodar este tutorial no R Studio Desktop:** 
Embora seja importante usar a versão no Desktop, não recomendamos se preocupar com esta etapa no início do seu aprendizado, porque podem surgir diferentes problemas relacionados à instalação e ao seu computador. Caso complete este tutorial e se sinta à vontade em utilizar a versão baixada do RStudio, saiba que esses problemas são comuns e já foram resolvidos, muito provavelmente, e estão disponíveis na internet. Mesmo assim, se for necessário, nos contacte!

**Passo 1: Acesse o GitHub**

-   Abra o seu navegador web e vá para o site do GitHub em <https://github.com/wapsyed/cursor>.

**Passo 2: Baixe o projeto**

-   No repositório do GitHub, clique no botão verde "Code".

-   Selecione "Download ZIP". Isso iniciará o download do arquivo ZIP contendo o projeto.

**Passo 3: Descompacte o arquivo ZIP**

-   Após o download ser concluído, localize o arquivo ZIP em sua pasta de downloads.

-   Clique com o botão direito do mouse no arquivo ZIP e selecione "Extrair tudo" ou "Descompactar".

-   Escolha a pasta de destino onde deseja descompactar o arquivo e clique em "Extrair".

**Passo 4: Configure o projeto no RStudio**

-   Abra o RStudio em seu computador. Caso não o tenha, siga as instruções e baixe o R e o R Studio [aqui](https://posit.co/download/rstudio-desktop/).

-   No menu do RStudio, clique em "File" (Arquivo) e selecione "New Project" (Novo Projeto).

-   Escolha a opção "Existing Directory" (Diretório Existente).

-   Navegue até a pasta onde você descompactou o projeto.

-   Selecione a pasta do projeto com um clique.

-   Clique em "Create Project" (Criar Projeto).

**Pronto! Agora você configurou o projeto do GitHub em seu RStudio e está pronto para começar a trabalhar.**

## Recomendações para evitar erros comuns

> 1.  **Para encontrar este documento com as linhas de códigos**, clique no arquivo **RMD** "**`Introducao_analise_exploratoria.rmd`**". Se clicar no `.md`, não funcionará.
> 2.  **Siga o tutorial todo neste documento ou crie uma copia para fazer as anotações**. Não se preocupe, que modificar este arquivo aqui não mudará nada no original do site.
> 3.  **Ao fazer a parte prática** com suas análises, faça no mesmo documento. Se estiver muito complicado, mande mensagem no grupo do Whatsapp ou envie um e-mail. A prática deve ser fácil e descomplicada.
> 4.  **Lembre-se de criar blocos de códigos abaixo dos blocos de códigos de exemplos do tutorial.** Também, descreva os gráficos e códigos no espaço em branco, ou seja, fora do bloco de código. Isso garantirá que seu documento estará organizado e fácil de alterar.

## **Curtiu este material?**

> Estamos disponibilizando este material de forma gratuita para, de alguma forma, compartilhar um conhecimento de qualidade e acessível para todos. Se você achou um material de boa qualidade e gostou do nosso trabalho, que tal nos ajudar com um valor simbólico?
>
> ☕ Nos pague um café clicando neste link e contribuindo com o valor que puder: <https://nubank.com.br/cobrar/vnb4e/664de10a-76e1-42b3-a566-1c1a1331cf22>

# Dia 1

# 1. Biblioteca e pacotes

Antes de rodarmos os códigos para as análises, é necessário instalar os pacotes cujos recursos, especialmente as funções, serão utilizados. Para isso, use o `install.packages("pacote")`[.]{.smallcaps}

Nem sempre é necessário reinstalar os pacotes, pois isso toma tempo. Entretanto, é recomendável reinstalar os pacotes de vez em quando, para atualizar o pacote.

Observe que o código abaixo está com `#` antes da função. Ao rodar pela primeira vez, retire estes `#` e execute clicando na linha do código e apertando `Ctrl + Enter`. Isso executará linha por linha. Caso queira rodar todas as linhas de uma vez, use `Ctrl + Shift + Enter`.

```{r message=FALSE, warning=FALSE}
options(repos = c(CRAN = "https://cran.r-project.org"))

# Baixar pacotes do CRAN para a biblioteca 
# install.packages("tidyverse")
# install.packages("skimr")
# install.packages("janitor")
# install.packages("esquisse")
# install.packages("ggthemes")
# install.packages("plotly")
# install.packages("gghighlight")
# install.packages("patchwork")
# install.packages("ggsci")
# install.packages("gapminder")
# install.packages("here")
# install.packages("gganimate")
# install.packages("scales")
# install.packages("GGally")
# install.packages("ggpmisc")
```

Após a instalação, a cada vez que você fechar o ambiente do R, você deverá chamar os pacotes da biblioteca com a função `library()`.

> **Lembre-se sempre de chamar os pacotes quando você iniciar uma nova sessão!**

Não se preocupe com os "erros" dos outputs ao chamar as libraries, especialmente as do tidyverse.

```{r message=FALSE, warning=FALSE}
# Chamando os pacotes da biblioteca
library(tidyverse) #Metapacote 
library(skimr) #Diagnóstico de tabela
library(janitor) #Limpeza de tabelas
library(esquisse) #Plotagem de gráficos prática
library(ggthemes) #Temas de ggplot
library(plotly) #Gráficos interativos
library(patchwork) #Unir gráficos
library(gghighlight) #Marcar pontos e linhas 
library(ggsci) #Paleta de cores 
library(gapminder) #Dataset sobre população, PIB e expectativa de vida dos países
library(ggpmisc) 
library(scales)
library(here)
library(gganimate)
library(GGally)
```

# 2. Operações básicas

Podemos criar variáveis de diferentes classes, como numéricas (integer, double), textuais (string/character), e muitas outras. Além disso, essas variáveis podem ser nomeadas com o nome que você quiser, como letras e palavras.

Entretanto, não podem ter espaço entre si `(variavel_a não é variavel a`) e, por mais que funcionem com palavras em portugues acentuadas ("`multiplicacão`"), é uma boa prática nomeá-las da forma mais simples possível, como `multiplicacao` ou `multi`.

```{r}
#Operações básicas -----

#Variáveis numéricas
x = 5
x

y = 7
y

z = y + x
z

multi = x * y
multi
```

As variáveis textuais são sempre definidas com aspas, mesmo sendo um número, como `string = "5"`.

> **Dica de ouro:** Nunca esqueça de fechar as aspas.

```{r}
# Variáveis textuais (characters, string)
a = "Olá" #Uma palavra
a

b = "Tudo bem?" #Uma frase
b
```

**Operações lógicas**

Se usarmos operadores lógicos para determinar se o conteúdo de uma variável é igual (`==`), diferente (`!=`), maior (`>`) ou menor (`<`), os resultados retornarão `TRUE` ou `FALSE`.

```{r}
# Comparações lógicas (booleanas)
a == b #Igual?
a != b #Diferente?
x < y # Menor?
x > y # Maior?
x <= 5 # Menor ou igual?
```

E, se criarmos outras variáveis com nomes diferentes, mas com os mesmos valores, elas ainda continuarão dando o mesmo resultado.

```{r}
aa = "Olá"
aa == a 
```

## Vetores

Os vetores são uma **sequência unidimensional** que podem ser números, strings, valores lógicos, entre outros. Podemos criar vetores com a função `c()`, de "concatenar".

> **Dica de ouro**: Nunca deixe de fechar os parênteses em uma função, pois isso dará erro.

```{r}
# Vetores
i = c(7, 5, 9, 10)
i

j = c("Gene", "Vacinado", "COVID-19")
j

```

Perceba que, para um vetor ser classificado como numérico, todos os elementos têm de ser números, isto é, não estar dentro de aspas. Do contrário, se um elemento for uma string (contiver aspas), mesmo com um número dentro, do vetor inteiro será convertido em strings.

```{r paged.print=TRUE}
h = c(7, "10", 78)
h

```

## Obtendo ajuda com funções

O `c()` é um exemplo de função. Toda função contem um nome seguido por parenteses. No caso da função `c()`, inserimos os elementos que temos interesse.

No entanto, outras funções que iremos aprender a seguir funcionam de forma diferente, muitas vezes intuitiva. Para acessar a documentação da função, use um `?` antes da função e aguarde a aba de ajuda abrir.

```{r}
# O que esta função faz? Use o "?" antes da função e rode.
?c()
```

## Dataframes e tibbles

Dataframes e tibbles são tabelas comuns e consistem de linhas e colunas de diferentes classes, como números, caracteres e fatores.

As **tibbles são diferentes dos dataframes** somente em sua apresentação no console e facilitam muito o trabalho com tabelas grandes e largas.

Além disso, a criação do dataframe e da tibble são diferentes visualmente. Enquanto no dataframe usamos a função `data.frame()` para criar colunas com linhas definidas por um vetor, na tibble esse código é semelhante à forma que imputamos dados no excel.

```{r paged.print=TRUE}
#Dataframes e tibbles -----

#Dataframe
data = data.frame(
  gene = c("Gene1", "Gene2", "Gene3", "Gene4"),
  variavel1 = c(1.59, 1.60, 1.78, 1.73),
  variavel2 = c(30, 25, 31, 32)
)
data
```

E para criar uma tibble, usamos a função `tribble()`**.**

```{r}
#Tibble
tibble = tribble(
  ~gene, ~variavel1, ~variavel2,
  "Gene1", 1.59,   30,
  "Gene2",   1.60,   25,
  "Gene3", 1.65,  31,
  "Gene4",   1.73,   32 
  )

tibble
```

**É possível transformar quase todo objeto em uma tabela.**

Por exemplo, se pegarmos os vetores criados anteriormente e usarmos a função `as.data.frame()`, será criada uma coluna com o nome do vetor, seguida por linhas contendo os elementos do vetor. É padrão no tidyverse e no R de, ao converter uma estrutura de dados em outra, usar o "`as`", como `as.data.frame()`, `as.matrix()`, `as.vector()`, etc.

```{r}
# Vetores em dataframe
as.data.frame(i) #dataframe com coluna numérica
as.data.frame(j) #dataframe com coluna textual
as.data.frame(h) #dataframe com coluna textual, mesmo com valores numéricos
```

**Há diferentes formas de se visualizar uma tabela.**

A diferença de cada objeto está na visualização no console e no documento. **Teste estas linhas de código no documento Markdown e no console.**

```{r}
#Visualizando o dataframe -----
# Com print()
print(data) #No documento ou console
print(tibble)

# Com nome do objeto
data
tibble 

# Com glimpse(). #Descrição mais completa da tabela
glimpse(data) 
glimpse(tibble)

# Com view() ou View(). A tabela completa com mais funcionalidades (filtragem manual, pesquisa e ordenamento) abrirá em uma nova janela
view(data) 
view(tibble)

# Selecione o nome do objeto, segure Ctrl e clique com o botão direito do mouse.
data
tibble 
```

## Estatísticas gerais da tabela

O R possui uma função muito prática de análise estatística descritiva, a `summary()`.

No entanto, existem outros pacotes que realizam essas análises e até geram relatórios em HTML.

Um deles é o skimr, cuja função `skim()` gera três outputs, um semelhante ao summary, e outras duas tabelas com a quantidade de valores não disponíveis (NA), estatísticas descritivas, e um histograma.

```{r}
# Estatísticas gerais 
summary(tibble)
summary(data)

# Usando skim
skim(tibble)
skim(data)

```

## Pivotando tabelas: Long e Wide

As tabelas tidy possuem dois formatos, um largo (wide) e outro longo (long). Converter uma em outra é conhecido como **pivotagem**, e conhecer essas funções é importantíssimo para obter, manipular e explorar dados.

Para pivotar, utilizamos `pivot_longer()` e `pivot_wider()`. A pivotagem deve ser pensada com base na relação entre variáveis e seus valores.

Por exemplo, se tivermos uma tabela larga com 10 colunas com anos (de 1990 a 2000), podemos reduzi-las em uma só coluna chamada "anos", que facilitará a manipulação de dados. Isso alongará a tabela.

No exemplo abaixo, simplificamos todas as variáveis (`variavel1` e `variavel2`) em uma coluna (`variavel`), e jogamos os valores para uma única coluna (`valor`).

```{r}
# Trabalhando com dataframes -----
#Transformando outros formatos em dataframe

# Long table
data_long = pivot_longer(data, #Tabela 
             cols = c(variavel1, variavel2), #Colunas para alongar 
             values_to = "valor", # Estocar valores em uma nova coluna
             names_to = "variavel" # Estocar variáveis em uma nova coluna
             ) 
data
data_long
```

Mas, se quisermos deixá-la mais fácil de ser interpretada por humanos, podemos pivotá-la em uma tabela larga, igual à tabela original.

```{r}
# Wide table
data_wide = pivot_wider(data_long, #Tabela
            names_from = variavel, #Dividir níveis de uma coluna em novas colunas
            values_from = valor)   #Estocar valores relacionados à coluna nome 
                                   #e novas variáveis) 
data_wide
```

## Matrizes

É importante saber manipular matrizes para computar análises estatísticas, como a Principal Components Analysis.

As matrizes são estruturas tabelares cujos valores são **somente numéricos**. Ou seja, não podemos ter uma coluna com strings, por exemplo.

Para isso, é necessário converter a coluna de "nomes" (strings) em nomes de linhas (rownames) usando a função `column_to_rownames()`, e então converter a tabela em matriz, com o `as.matrix()`.

A diferença aqui é a apresentação da tabela. Enquanto dataframes e tibbles são facilmente lidas, as matrizes são mais complicadas nesse sentido.

```{r}
#Matriz
matrix = as.matrix(data) #Transformar tabela em matriz
matrix #Os valores numéricos são strings

data_matrix = column_to_rownames(data, "gene") #Converte coluna em rownames
matrix = as.matrix(data_matrix)
matrix #Agora, os valores são numéricos

```

**Caso você queira manipular a matriz com as funções do tidyverse**, é recomendável reconvertê-la em dataframe/tibble, manipular os dados, e depois converter novamente para matriz.

```{r}
# Reconverter para dataframe
matrix_dr = as.data.frame(matrix)

matrix_dr # Coluna "nome" continua como rownames e dificulta a manipulação.

matrix_dr = rownames_to_column(matrix_dr, "gene") #Converter rownames em nova coluna
matrix_dr
```

## Listas

Listas são estruturas que podem conter um conjunto de elementos de diferentes classes, como **vetores, outras listas, dataframes, e matrizes**.

Elas são interessantes para **organizar os objetos necessários para uma análise**, e são muito comuns em análises de RNAseq, por exemplo.

```{r}
#Criando a lista
lista = list(a, b, h, j, multi, data, matrix, tibble)

#View(lista) #Visualizando a lista

#Acessando objetos diferentes da lista
lista[[1]] #Primeiro objeto
lista[[8]] #Oitavo objeto

#Isolando o objeto
df_list = lista[[8]]
df_list

```

## Manipulação de tabelas com o R base

O R possui funções e formas nativas de acessar e manipular tabelas. Essas operações, como as descritas abaixo, não são mais a melhor forma de trabalhar, pois são pouco intuitivas, e vamos usar outras muito melhores a seguir. Mas, **é importante conhecê-las**, pois, são utilizadas em alguns casos.

Para acessar uma coluna no dataframe, digite o nome do dataframe seguido por `$` e o nome da coluna (`data$coluna`). Se você não lembra o nome da coluna, você pode digitar `data$` e apertar Tab.

```{r}
# Acessando colunas do data frame
data$gene
data$variavel1

```

Para adicionar uma nova coluna e preencher seus valores, crie um vetor com os valores e insira nessa coluna.

```{r}

# Criando nova variável para não sobrescrever a tabela original para os próximos exemplos
data_2 = data

# Adicionando uma nova coluna ao data frame
data_2$variavel3 = c(70, 
                65, 
                80, 
                20)
data_2

```

**Para remover uma coluna**, abra os colchetes `[linha, coluna]` após o nome do dataframe, selecione o índice da coluna e adicione um `-`. Os colchetes definem as linhas (antes da vírgula) e as colunas (depois da vírgula). Um pouco ~~muito~~ confuso, né?

```{r}
# Removendo uma coluna do data frame
data_3 = data_2[ , -4]
```

Para filtrar e reordenar os dados, é ainda pior.

```{r}
# Filtrando linhas do data frame. df[linha, coluna]
data_jovens = data_2[data_2$variavel3 < 30, ]
data_jovens

# Ordenando o data frame por uma coluna
data_ordenados <- data_2[order(data_2$variavel3), ]
data_ordenados
```

# 3. Tidyverse

O tidyverse é um **metapacote**, um pacote com diversos pacotes dentro, que facilita muito o trabalho no R. As funções conversam entre si, são padronizadas e, mais importante, são muito **intuitivas**.



## `filter():` Filtrando linhas e usando o pipe

Sempre que estivermos manipulando linhas, utilizamos o **verbo "filtrar"**. No tidyverse, mais especificamente no pacote dplyr, usamos a função `filter()` e estabelecemos argumentos lógicos para a filtragem.

```{r paged.print=TRUE}
# Filtrando linhas ----
variavel2 = filter(data, variavel2 <= 30)

gene_variavel2 = filter(variavel2,
                    gene == "Gene1")

gene_variavel2
```

Mas, e se eu quiser filtrar usando mais operações?

Temos duas formas de fazer isso.

A primeira é usando "OU" (`|`) e `%in% c()`. Veja que os resultados são iguais, mas a forma de escrever é diferente. No primeiro caso, temos de repetir "`nome ==`" a cada valor que quisermos incluir. No segundo caso, somente criamos um vetor com os valores separados por vírgula.

```{r paged.print=TRUE}
#Usando OU (|)
filter(data, gene == "Gene1" | 
           gene == "Gene3")

#Usando %in% c()
filter(data, gene %in% c("Gene1", "Gene2")) 

```

E a segunda é usando o **pipe** (`%>%`)**,** que permite "costurar" operações e resultados. Dessa forma, não precisamos criar uma variável/objeto sempre que uma função for aplicada. Usaremos muito o pipe nos próximos códigos.

Abaixo, pegamos uma tabela, filtramos por idade e, então, filtramos somente linhas que contêm um valor. No caso, pegamos as linhas com idade maior ou igual a 30 e, depois, aquelas que contêm o nome "Gabriela".

```{r paged.print=TRUE}
# Usando o pipe "%>%" (lê-se "e então")
data %>%                   # Tenho este objeto 
  filter(variavel2 >= 30) %>%  # E então vou filtrar os indivíduos com mais de 30 anos
  filter(gene == "Gene1")   # E então vou filtrar os indivíduos chamados "Gabriela"
```

## `select():` Selecionando colunas

Da mesma forma que trabalhamos com linhas usando `filter(),` ao trabalhar com colunas, usamos o `select()`.

A função select é muito versátil, e **além de selecionar colunas** que você quer trabalhar, podemos **reordená-las e renomeá-las manualmente**.

Para **isolar a(s) coluna(s)**, use `select(coluna)`, que você produzirá uma tabela com somente aquela coluna.

Para **retirar** uma coluna, use o `-` ou o `!`.

Para **reordenar**, use `select(coluna, everything())`. Aqui, você coloca a coluna de interesse em primeiro lugar e todas as outras restantes em sequência.

```{r paged.print=TRUE}
# Selecionando colunas ----
# Selecionar colunas específicas
data_2 %>%
  select(gene, variavel1) 

# Selecionar da coluna gene (1) à coluna variavel2 (3)
data_2 %>% 
  select(gene:variavel2) 

#Retirando coluna
data_2 %>% 
  select(-variavel2) 

data_2 %>%   
  select(!variavel2)

#Reordenando coluna
data_2 %>%   
  select(variavel2, everything())

```

Para **renomear** uma coluna, é possível também usar o `rename().

```{r paged.print=TRUE}
#Renomeando coluna com rename
data_2 %>%   
  rename(expression = variavel1) #Retirando coluna

```

## `mutate():` Criando e realizando operações com novas variáveis

A função `mutate()` permite **criar ou modificar colunas** e imputar valores usando funções que se aplicarão a todas as linhas daquela coluna. Por exemplo, podemos criar a coluna imc com o IMC todos os indivíduos, que é calculado com a razão do peso e a altura ao quadrado.

```{r paged.print=TRUE}
# Criando novas variáveis
data_2 = data_2 %>%
  mutate(factor = variavel2 / (variavel1^2)) #Para cada linha da tabela, 
                                  #pegaremos o valor da variavel2 e dividiremos 
                                  #pela variavel1 ao quadrado.

```

Além disso, podemos criar uma coluna com a espécie do indivíduo. Como sabemos que todos humanos, podemos fazer dessa forma.

```{r paged.print=TRUE}
data_2 %>% 
  mutate(species = "human") #Como todas as linhas contêm nomes 
                            #femininos, criaremos a coluna species 
                            #com o valor "human"
```

## `if_else` e `case_when()`: Condições

Mas, podemos também usar um argumento lógico também.

Por exemplo, podemos criar uma coluna que classificará se a pessoa está acima ou abaixo de um IMC específico, a partir dos valores da coluna `imc`.

Isso é feito com a função `if_else(),` que é lida da seguinte forma: se isso for verdadeiro, dê o valor "A", do contrário, "B". No caso aqui, se a pessoa tiver um IMC acima de 25, ela será considerada com sobrepeso, e se for abaixo, será classificada como normal.

```{r paged.print=TRUE}
data_2 %>% 
  mutate(classification = if_else(factor > 10, "super", "normal"))
```

Mas, sabemos que o IMC pode ser classificado com outras categorias. Para isso, temos o `case_when()`, que é um if_else mais versátil e deixa o código mais limpo e fácil de ler.

```{r paged.print=TRUE}
data_2 = data_2 %>% 
  mutate(classification = case_when(factor >= 11 ~ "super",
                                   factor > 10 & factor < 11 ~ "normal",
                                   factor < 10 ~ "under"))
```

## summarize(): resumindo estatísticas

A função `summarize()` (ou `summarise()`) aplica a mesma lógica, mas a tabela gerada é muito menor, e se aplica à variável de interesse na tabela. Por exemplo, se quisermos obter a média (`mean()`), e a soma (`sum()`) das linhas de uma coluna, a summarize é capaz de fazer isso.

```{r paged.print=TRUE}
# Resumindo dados
data_2 %>% 
  summarize(mean = mean(variavel1))

data_2 %>% 
  summarize(sum = sum(variavel1))
```

## `group_by`: Agrupando dados

Em muitos casos, nós queremos realizar cálculos com categorias ou grupos diferentes. Por exemplo, considere que queremos saber a média (`mean()`) das idades por categoria da classificação pelo IMC, e além disso, queremos contar os indíviduos em cada categoria (`n()`). Para isso, temos de agrupar os dados por categorias (`sobrepeso, normal`, etc.) de uma variável (`classificacao`). Isso é feito com o `group_by()` seguido pelo `summarize()`.

```{r paged.print=TRUE}
#Média dos grupos
data_2 %>% 
  group_by(classification) %>% 
  summarize(mean = mean(variavel2))

#Contagem
data_2 %>% 
  group_by(classification) %>% 
  summarize(n = n())
```

## `arrange():` Ordenando dados

Podemos ordenar os dados de forma crescente e decrescente usando o `arrange().`

```{r paged.print=TRUE}
# Ordenando dados de forma crescente
data_2 %>% 
  arrange(variavel1)

# Ordenando de forma decrescente
#Método 1
data_2 %>% 
  arrange(desc(variavel1))

#Método 2
data_2 %>% 
  arrange(-variavel1)
```

## Joins: merging/unindo tabelas

Na rotina de análise dados, temos de lidar com diferentes tabelas que, muitas vezes, estão associadas entre si por algum elemento. Por exemplo, podemos ter uma tabela com os dados antropométricos (altura, idade e peso) para cada indivíduo e outra com informações pessoais, como endereço, telefone, etc.

**"Uai, mas não posso ter tudo em uma tabela só?"**. Pode, mas precisamos considerar que uma tabela com todos esses dados não são necessariamente úteis em todo o processo. Acima, avaliamos o IMC de cada indivíduo e não seria interessante saber o endereço de cada um. Mas, se tivermos uma tabela enorme, com milhões de pessoas, podemos procurar estabelecer uma associação entre peso e endereço, por exemplo. Ou mesmo encontrar relações entre essas variáveis e a incidência de alguma doença infecciosa.

Dessa forma, é importante construir e dividir tabelas para facilitar nossa manipulação de dados e, não menos importante, reduzir o **tamanho dos arquivos individuais**.

Para ilustrar isso, vamos criar uma tabela chamada `endereco`, que contem o nome, cidade e bairro de cada indivíduo.

```{r paged.print=TRUE}
gene_info = tribble(~gene, ~type, ~process,
          "Gene1", "Pseudogene", "Immune",
          "Gene2", "Protein-coding", "Metabolism",
          "Gene3", "miRNA", "Immune",
          "Gene4", "Protein-coding", "Cellular",
          "Gene5", "Protein-coding", "Regulation")
gene_info
```

Uma forma de unir a tabela `data_2` com a tabela `endereco` é pelas linhas de uma coluna em comum, no caso a coluna `nome`. Essa operação é chamada de **merging**. Para isso, temos as funções `*_join()`. O `*_` seguido por `join()` significa que existem nomes diferentes de funções que terminam com "join" e fazem algo parecido.

### inner_join()

Uma dessas funções é a `inner_join()`, que somente une as linhas correspondentes de duas tabelas. Ou seja, se tem uma linha com o nome X nas tabelas 1 e 2, as colunas das tabelas 1 e 2 serão unidas. Se existir uma linha com o nome X na tabela 1, mas não na tabela 2, então as colunas não serão unidas para aquela linha. Confuso, mas você vai entender visualizando aqui.

```{r paged.print=TRUE}
data_2 %>% #Tabela original (tabela 1)
  inner_join(gene_info, #Tabela para unir (tabela 2)
             by = "gene") #Coluna correspondente
```

Veja que a "Rafaela" não foi incluída, porque não havia dados sobre ela na tabela de endereços.

### left_join()

Mas, suponhamos que seria interessante saber quem da tabela 1 **não** tem endereço cadastrado e, dessa forma, podemos procurar registrar em outra ocasião. Para isso, temos o `left_join()`. Nele, em vez de não mostrar a linha da Rafaela na nova tabela, a função inclui valores `NA` nessa linha. A função tem o nome de "**left**" porque considera a tabela 1 como a tabela da esquerda. **Em outras palavras**, queremos anotar todas as linhas da tabela da esquerda (tabela 1) com os dados da tabela da direita (tabela 2) a partir dos elementos da coluna em comum chamada "`nome`".

```{r paged.print=TRUE}
data_2 %>% #Tabela original (tabela 1)
  left_join(gene_info, #Tabela para unir (tabela 2)
             by = "gene") #Coluna correspondente
```

### anti_join()

Da mesma forma, podemos obter somente as linhas que estão na tabela 1, mas não na tabela 2. Isso é feito com a função `anti_join()`. O output dela é somente a linha da Rafaela com as colunas da tabela 1.

```{r paged.print=TRUE}
data_2 %>% #Tabela original (tabela 1)
  anti_join(gene_info, #Tabela para unir (tabela 2)
             by = "gene") #Coluna correspondente

gene_info %>% #Tabela original (tabela 2)
  anti_join(data_2, #Tabela para unir (tabela 1)
             by = "gene") #Coluna correspondente
```

### right_join()

Observe que a tabela `endereco` também tem uma linha que não está na tabela 1, a "Thais", e que ela não foi mostrada nas funções anteriores. Para incluir, podemos usar o right_join(), que assim como o left_join(), mostra todas as linhas de uma tabela, incluindo aquelas que não estão na outra. No caso, ela mostra todas as linhas da tabela 2, mesmo aquelas que não estão anotadas com os dados da tabela 1. Além disso, ela não mostra as linhas da tabela 1 que não estão na tabela, no caso "Rafaela".

```{r paged.print=TRUE}
data_2 %>% #Tabela original (tabela 1)
  right_join(gene_info, #Tabela para unir (tabela 2)
             by = "gene") #Coluna correspondente
```

### full_join()

Agora, se quisermos ter uma tabela completa, com todas as linhas das tabelas 1 e 2, mesmo aquelas que não correspondem entre si, usamos a função `full_join()`.

```{r paged.print=TRUE}
data_2 %>% #Tabela original (tabela 1)
  full_join(gene_info, #Tabela para unir (tabela 2)
             by = "gene") #Coluna correspondente
```

## Usando o `pipe` para fazer múltiplas operações de uma vez

Usando o pipe, podemos escrever e ler códigos em uma sequência lógica fácil.

Por exemplo, abaixo:

> 1.  *pegamos a tabela `data_2`, **ordenamos** a altura na ordem crescente,*
> 2.  ***filtramos** somente as pessoas com idade acima de 30 e peso acima de 50 e **retiramos** os nomes.*
> 3.  *Depois, **arredondamos** os valores do IMC para uma casa decimal (usando `round())` e **criamos uma nova variável** chamada `peso_x_idade`.*
> 4.  *Por fim, **resumimos** os dados usando a média do peso e a média do imc, e criamos uma variável chamada `mega_pipe`*

```{r}
# Múltiplas operações em uma caixa
mega_pipe = data_2 %>% 
  arrange(variavel2) %>% 
  filter(variavel2 >= 30,
         variavel3 >= 50) %>% 
  select(-gene) %>% 
  mutate(factor = round(factor, 1),
         var1_x_var2 = variavel1 * variavel2) %>%
  summarise(mean = mean(variavel2),
            mean = round(mean, 1),
            mean_factor = mean(factor) %>% round(1))
mega_pipe
```

# 4. Visualização

A visualização com o `ggplot2` é feito em **camadas**. Primeiro, temos um dataframe com os dados de interesse, depois chamamos a função `ggplot()` e adicionamos um `+`, que funciona aqui como um pipe, mas somente para gráficos. A partir disso, temos de mapear os eixos, cores, tamanho, etc. com as variáveis de interesse, usando o `aes()`. Para definir qual tipo de gráfico iremos criar, temos de definir a geometria (`geom_`), que no caso é de pontos (`geom_point()`). Isso já produz um gráfico, mas não é um dos melhores.

## Gráfico de barras

```{r}
data_2 %>% 
  ggplot() +
  aes(x = gene,
      y = factor) +
  geom_col()
```

Para melhorar, podemos adicionar mais funções, como labels para os pontos do gráfico (`geom_label()`), um tema pré-definido (`theme_few()`) ou customizável (`theme()`), e **título** para o gráfico, **eixos**, e **legendas** (`labs())`. Além disso, para **reordenar** os valores de uma variável categórica, como os países, por uma variável numérica, usamos o `fct_reorder()` dentro do `mutate()`.

```{r}
data_2 %>% 
  ggplot() +
  aes(x = fct_reorder(gene, -factor), #Mapeando variáveis
      y = factor) +
  geom_col() + #Geometria
  theme_minimal() + #Tema 
  labs(x = "Gene", #Títulos
       y = "Factor",
       title = "Factor")
```

Observe que a fonte dos eixos x e y estão muito pequenas e difíceis de visualizar. Conseguimos mudar facilmente esses atributos usando a função `theme()` e os argumentos `axis.text.x` e `axis.text.y`. Além disso, podemos melhorar o título do gráfico, deixando-o em negrito (`face = "bold"`) e centralizado ou justificado ao meio (`hjust`). Para isso, devemos usar a função `element_text(),` que aceita como parâmetros `size`, `color`, `face`, `angle`, etc. Não confunda com `theme_few()` ou qualquer outro tema pronto. Veja também que, quando adicionamos modificações no `theme()`, o `theme_few()` permanece como estava.

```{r}
data_2 %>% 
  ggplot() +
  
  #Mapeando variáveis
  aes(x = fct_reorder(gene, -factor), 
      y = factor) +
  
  #Geometria
  geom_col() + 
  
  #Tema pré-estabelecido
  theme_minimal() + 
  
  #Modificando o tema
  theme(axis.text.x = element_text(size = 10,
                                   color = "black"),
        axis.text.y = element_text(size = 10,
                                   color = "black"),
        plot.title = element_text(size = 12,
                                  color = "black",
                                  hjust = 0.5,
                                  face = "bold")) +
  #Títulos
  labs(x = "Gene", 
       y = "Factor",
       title = "Factor by gene")
```

## Cores

Agora, vamos adicionar cores ao gráfico. Como vamos preencher os retângulos de acordo com os valores de uma variável (`classificacao`), atribuimos o nome da variável ao argumento `fill` em aesthetics (`aes()`). Adicionalmente, vamos renomear o título da legenda para o `fill` usando a função `labs()` e deixar os níveis começando com a letra maíuscula usando a função `scale_fill_discrete()`.

```{r}
data_2 %>% 
  ggplot() +
  
  #Mapeando variáveis
  aes(x = fct_reorder(gene, -factor), 
      y = factor,
      fill = classification) +
  
  #Geometria
  geom_col() + 
  
  #Tema pré-estabelecido
  theme_light() + 
  
  #Modificando o tema
  theme(axis.text.x = element_text(size = 10,
                                   color = "black"),
        axis.text.y = element_text(size = 10,
                                   color = "black"),
        plot.title = element_text(size = 12,
                                  color = "black",
                                  hjust = 0.5,
                                  face = "bold")) +
  #Títulos
  labs(x = "Gene", 
       y = "Factor",
       title = "Factor") +
  
  #Renomeando levels
  scale_fill_discrete(labels = c("under" = "Under", 
                               "normal" = "Normal",
                               "super" = "Super")) 
```

Por padrão, o ggplot2 utiliza uma paleta de cores nativa, mas podemos especificar a de nosso interesse. Existem diversos pacotes com paletas pré-definidas. Um dos pacotes é o `ggsci`, que apresenta as paletas dos principais journals acadêmicos, como a Nature, Science, e a The Lancet, além de filmes e séries de ficção, como jama, Tron e Futurama. Para acessar as paletas, use `vignette("ggsci"),` e para visualizar os códigos das cores, especifique a paleta usando `pal_` e depois `show_col()`. Aqui, usaremos a paleta dos **jama**. Definir as paletas é uma etapa importante para garantir a padronização dos gráficos no seu trabalho.

```{r message=FALSE, warning=FALSE}
# Cores
#Mudando a paleta
vignette("ggsci") 

jama = pal_jama("default", #Especificar paleta
              alpha = 0.7)(8) #Gerar 8 cores com transparencia = 70%
jama %>% 
  show_col()
```

```{r}
data_2 %>% 
  ggplot() +
  
  #Mapeando variáveis
  aes(x = fct_reorder(nome, -imc),
      y = imc,
      fill = classificacao) +
  
  #Adicionando geometrias
  geom_col() +
  
  #Tema pré-estabelecido
  theme_light() + 
  
  #Adicionando títulos
  labs(x = "Nome", 
       y = "IMC",
       title = "Índice de massa corporal por pessoa",
       fill = "Classificação") +
  
  #Modificando o tema
  theme(axis.text.x = element_text(size = 10,
                                   color = "black"),
        axis.text.y = element_text(size = 10,
                                   color = "black"),
        plot.title = element_text(size = 12,
                                  color = "black",
                                  hjust = 0.5,
                                  face = "bold")) +
  
  #Renomeando levels
  scale_fill_discrete(labels = c("magreza" = "Magreza", 
                               "normal" = "Normal",
                               "obesidade 1" = "Obesidade I")) +
  scale_fill_jama()
```

E se quisermos definir uma paleta manualmente, podemos usar a função `scale_fill_manual()`, na qual atribuimos as cores específicas a cada categoria. Observe que podemos escrever o nome da cor ou o código, e o RStudio interpretará no próprio bloco de código. Para ver mais cores, acesse o site [coolors.co](https://coolors.co/). Lembre-se de sempre adicionar um `#` antes do código da cor.

```{r}
barras = data_2 %>% 
  ggplot() +
  aes(x = fct_reorder(nome, -imc),
      y = imc,
      fill = classificacao) +
  geom_col() +
  labs(x = "Nome", #Títulos
       y = "IMC",
       title = "Índice de massa corporal",
       fill = "Classificação") +
  
  #Tema pré-estabelecido
  theme_light() + 
  
  #Modificando o tema
  theme(axis.text.x = element_text(size = 10,
                                   color = "black"),
        axis.text.y = element_text(size = 10,
                                   color = "black"),
        plot.title = element_text(size = 12,
                                  color = "black",
                                  hjust = 0.5,
                                  face = "bold")) +
  
  scale_fill_discrete(labels = c("magreza" = "Magreza", 
                               "normal" = "Normal",
                               "obesidade 1" = "Obesidade I")) +
  scale_fill_manual(values = c("magreza" = "red", 
                               "normal" = "blue",
                               "obesidade 1" = "#ffb703"))

barras
```

## Gráfico de dispersão

Um gráfico com pontos que relaciona duas variáveis numéricas é interessante para visualizar uma associação. Vamos fazer exatamente o que fizemos com os gráficos de barras, mas agora definiremos a geometria com `geom_point()` e a cor será definida pelo argumento color. Ao definirmos as cores de pontos e linhas (unidimensionais), usamos `color`, e no caso de formas geométricas bidimensionais como barras e colunas, usamos `fill`. Além disso, podemos adicionar uma paleta de cores para cada nível da variável classificacao com `scale_color_*()`.

```{r}

data_2 %>% 
  ggplot() +
  aes(x = peso,
      y = imc,
      color = classificacao) +
  geom_point() +
  
  #Títulos
    labs(x = "Peso (kg)", 
       y = "IMC",
       title = "Índice de massa corporal versus peso",
       color = "IMC") +
  
  #Tema pré-estabelecido
  theme_light() + 
  
  #Modificando o tema
  theme(axis.text.x = element_text(size = 10,
                                   color = "black"),
        axis.text.y = element_text(size = 10,
                                   color = "black"),
        plot.title = element_text(size = 12,
                                  color = "black",
                                  hjust = 0.5,
                                  face = "bold"))  +
  
  #Cores
  scale_color_jama()
```

Além disso, podemos criar um gradiente usando `scale_color_gradient()` e definindo as cores pros valores mínimo e máximo.

```{r}
data_2 %>% 
  ggplot() +
  aes(x = peso,
      y = imc,
      color = imc) +
  geom_point() +
  
  #Títulos
    labs(x = "Peso (kg)", 
       y = "IMC",
       title = "Índice de massa corporal versus peso",
       color = "IMC") +
  
  #Tema pré-estabelecido
  theme_light() + 
  
  #Modificando o tema
  theme(axis.text.x = element_text(size = 10,
                                   color = "black"),
        axis.text.y = element_text(size = 10,
                                   color = "black"),
        plot.title = element_text(size = 12,
                                  color = "black",
                                  hjust = 0.5,
                                  face = "bold"))  +
  
  #Gradiente de cores
  scale_color_gradient(low = "yellow", 
                       high = "brown", 
                       na.value = NA)
```

## Adicionando mais geoms

Por enquanto, somente visualizamos gráficos com uma geometria, mas podemos adicionar mais de uma. Agora, adicionaremos uma linha (`geom_line()`) para conectar os pontos. Além disso, vamos definir outros parâmetros para essas geometrias, como espessura (`size`) da linha e do ponto. Lembre-se que o ggplot2 é um sistema de camadas, então se adicionarmos a linha antes dos pontos no código, os pontos irão se sobrepor às linhas.

```{r}
linha = data_2 %>% 
  ggplot() +
  
  #Mapping
  aes(x = peso,
      y = imc,
      color = imc) +
  
  #Geometriasw
  geom_line(size = 2) +
  geom_point(size = 4) +
  
  #Títulos
    labs(x = "Peso (kg)", 
       y = "IMC",
       title = "Índice de massa corporal versus peso",
       color = "IMC") +

  #Tema pré-estabelecido
  theme_light() + 
  
  #Modificando o tema
  theme(axis.text.x = element_text(size = 10,
                                   color = "black"),
        axis.text.y = element_text(size = 10,
                                   color = "black"),
        plot.title = element_text(size = 12,
                                  color = "black",
                                  hjust = 0.5,
                                  face = "bold"))  +
  
  #Gradiente de cores
  scale_color_gradient(low = "yellow", 
                       high = "brown", 
                       na.value = NA)

linha
```

## Salvando figuras

Para salvar uma figura, vamos usar a função `ggsave()` e definir como tipo de arquivo `.png` e usar a função `here()`, que especifica o caminho do diretório ao qual salvaremos a figura. No caso, salvaremos dentro da pasta "Figuras".

Há diferentes tipos de arquivos, como jpeg e tiff, mas usaremos o png por ser muito comum e também ser aceito por diferentes programas de edição, como o Google Slides, Powerpoint e Canva. Além disso, vamos definir também as dimensões da imagem final.

```{r}
linha %>% 
  ggsave(file = here("Figuras","linha_imc.png"), width = 5, height = 5)
```

Uma outra forma de salvar a imagem é colar `linha` no console, printá-la (apertar `Enter`) e salvar diretamente da aba "Plots". Você poderá salvá-la como .png ou como pdf também!

## Gráfico interativo: Plotly

Em alguns casos, converter um gráfico estático em um interativo é muito interessante para explorar os dados, especialmente em gráficos com pontos mais complexos do que este. Para isso, usamos o pacote `plotly`.

```{r message=FALSE, warning=FALSE}
linha %>% 
  ggplotly() 
```

## Visualização rápida com o Esquisse

O pacote **`esquisse`** é uma ferramenta interativa para a construção de gráficos, de forma rápida e intuitiva.

**Lembre-se de retirar os `#` antes de rodar.** Teste todos os parâmetros, como filtragem, cores, escalas, e veja como os dados se comportam nos diferentes tipos de gráficos. Observe também, no botão do lado inferior direito, que você pode gerar os códigos do gráfico e copiar para o bloco de código. Dessa forma, você automatiza seu gráfico sem precisar ficar abrindo esta janela sempre.

```{r}
# data_2 %>% 
#   esquisser()
```

## Uma figura, mais gráficos

Geramos diferentes gráficos acima. Entretanto, é interessante uni-los em uma só imagem. Afinal, são os mesmos dados explorados de formas diferentes. Para isso, temos o pacote patchwork, que funciona da forma mais simples possível usando operadores matemáticos, como `+`, `/` e `().`

Para colocar um gráfico do lado do outro, use `+`.

```{r}
linha + barras + plot_layout(guides = "collect")
```

E para colocar um gráfico em cima do outro, use `/`.

```{r}
linha / barras + plot_layout(guides = "collect")
```

Para salvar, usaremos a mesma função `ggsave()`.

```{r}
linha_barra = linha / barras + plot_layout(guides = "collect")

ggsave(linha_barra, file = here("Figuras","linha_barra.png"), width = 10, height = 5)
```

# Dia 2

# 5. Trabalhando com dados de bioinformática

Importando dados
```{r}
metadata <- read_csv("Bioinformática/metadata.csv")
expression_data <- read_csv("Bioinformática/expression_data.csv")
```
Limpando dados
```{r}
library(janitor)
metadata = metadata %>% 
  clean_names()
```

Transformando dados

Em matriz
```{r}
#Transformar em matriz
expression_data_matriz = expression_data %>% 
  column_to_rownames("gene") %>% 
  as.matrix()
```

Em tabela longa
```{r}
#Transformar em tabela longa
expression_data_long = expression_data %>%
  pivot_longer(cols = -gene,
               names_to = "sample",
               values_to = "value")
```

Anotando dados
```{r}
#Unir duas tabelas com anotações
expression_data_long_metadata = expression_data_long %>% 
  inner_join(metadata, by = "sample")
```

Visualizando dados
```{r eval=FALSE, include=FALSE}
expression_data_long_metadata %>% 
  filter(gene == "Gene_1") %>% 
  esquisser()
```

Histograma
```{r}
library(ggsci)
expression_data_long_metadata %>% 
  filter(gene == "Gene_1") %>%
  ggplot()+
  aes(x = value, fill = condition) +
  geom_point(aes(x = value, color = condition),
             y = -0.1) +
  geom_histogram(bins = 6L) +
  scale_fill_npg() +
  scale_color_npg() +
  theme_classic()
  
```
Gráfico de densidade
```{r}
expression_data_long_metadata %>% 
  filter(gene == "Gene_1") %>%
  ggplot()+
  aes(x = value, fill = condition) +
  geom_density(alpha = 0.8) +
  theme_classic() +
  scale_fill_npg()
```

Boxplot simples
```{r}
expression_data_long_metadata %>% 
  filter(gene == "Gene_1") %>%
  ggplot()+
  aes(x = condition,
      y = value, 
      fill = condition) +
  geom_boxplot() + 
  theme_classic() +
  scale_fill_npg()
```
Boxplot com violing plot e pontos
```{r}
p = expression_data_long_metadata %>% 
  filter(gene == "Gene_1") %>%
  ggplot()+
  aes(x = condition, 
      y = value, 
      fill = condition) +
  geom_violin(alpha = 0.5) +
  geom_boxplot(width = 0.4) +
  geom_point() +
  theme_classic() +
  scale_fill_npg() +
  labs(x = "Condition",
       y = "Expression",
       fill = "Condition",
       title = "Gene 1",
       subtitle = "Gene expression by condition")

p

```
Gráfico de barras com intervalo de confiança 95%
```{r}
table_genes_1_2 = expression_data_long_metadata %>% 
  group_by(condition, gene) %>% 
  summarize(mean = mean(value),
            sd = sd(value),
            n = n(),
            std_error = sd / sqrt(n),
            lower_bound = mean - 1.96 * std_error,
            upper_bound = mean + 1.96 * std_error)

table_genes_1_2 %>% 
  ungroup() %>% 
  filter(gene == "Gene_1") %>%
  ggplot()+
  aes(x = condition, 
      y = mean, 
      fill = condition) +
  geom_col() +
  geom_errorbar(aes(ymin = lower_bound, ymax = upper_bound), 
                width = 0.1) +
  theme_classic() +
  scale_fill_npg()+
  labs(x = "Condition",
       y = "Expression",
       fill = "Condition",
       title = "Gene 1",
       subtitle = "Mean gene expression by condition")

```
Teste t com ggpubr
```{r}
library(ggpubr)
my_comparisons <- list( c("Condition_A", "Condition_B"))
p + 
  stat_compare_means(comparisons = my_comparisons, 
                     method = "t.test")
```

Gráfico de dispersão
```{r}
expression_data_long_metadata %>% 
  filter(gene %in% c("Gene_1", "Gene_2")) %>%
  pivot_wider(names_from = "gene",
              values_from = "value") %>% 
  ggplot()+
  aes(x = Gene_1, 
      y = Gene_2, 
      color = condition) +
  geom_point(size = 3) +
  theme_classic() +
  scale_color_npg() +
  labs(x = "Gene 1",
       y = "Gene 2",
       color = "Condition",
       title = "Gene 1 vs Gene 2",
       subtitle = "Gene expression by condition") +
  theme(legend.position = "top")
```

Heatmap
```{r fig.height=10, fig.width=10}
library(ggheatmap)
library(circlize)
library(ComplexHeatmap)
library(scales)

heatmap_table = expression_data %>% 
  column_to_rownames("gene") %>% 
  as.matrix()


annotation_col = metadata %>% 
  column_to_rownames("sample") %>% 
  mutate(condition = as.factor(condition))

col = colorRamp2(c(0, 10, 20), c("white", "red", "black"))


colors_annotations = list(condition = c("Condition_A" = "gray90",
                                                "Condition_B" = "steelblue"))

col_ha = HeatmapAnnotation(df = annotation_col, 
                       col = colors_annotations, 
                       annotation_name_side = "left")

Heatmap(heatmap_table, 
        top_annotation = col_ha,
        cluster_rows = T,
        cluster_columns = T, 
        cluster_row_slices = T,
        cluster_column_slices = T,
        col = col,
        column_split = 2,
        row_split = 3
        ) 
```







# Agora é a sua vez!

Faça gráficos analisando continentes, países, doenças e vacinas diferentes. Para isso, é só trocar os nomes nas funções dos gráficos. Por exemplo, onde estiver "`Brazil`", coloque "`Canada`" ou "`India`", etc. Da mesma forma, onde estiver o nome de uma vacina ou doença, troque pelos temas do seu interesse. Para selecionar os países, não há critério definido, então você poderá ir pela sua curiosidade ou por meio dos gráficos já apresentados, como o boxplot interativo.

**Recomendações**

1.  **Ao fazer a parte prática com suas análises, faça no mesmo documento**. Se estiver muito complicado, mande mensagem no grupo do Whatsapp ou envie um e-mail. A prática deve ser fácil e descomplicada.

2.  **Lembre-se de criar blocos de códigos abaixo dos blocos de códigos de exemplos do tutorial.** Também, descreva os gráficos e códigos no espaço em branco, ou seja, fora do bloco de código. Isso garantirá que seu documento estará organizado e fácil de alterar.

    **Por exemplo:**

```{r}
#Código exemplo
#...
```

> "Meu código... Gráfico do tipo A dos países XYZ."

```{r}
#Seu código
#...
```

**Alguns exemplos de perguntas que você pode se fazer:**

-   **Quem**:

    -   Quais são os **países** que **menos** vacinaram em cada **continente**?

    -   Quais são os **países** que **mais** vacinaram em cada **continente**?

    -   Quais são os **países** que **mais** tiveram **mortes** por uma **doença X**? A **difteria** aparentemente teve um surto em algum país **latinoamericano** a partir de **2016**. Qual é este país e por que isso ocorreu? Será que é a baixa **cobertura vacinal**?

-   **Quando**:

    -   Será que a cobertura vacinal ou o número de mortes **sempre** foi assim (alto ou baixo) ou é algo **recente** dos últimos 5 a 10 anos?

    -   Será que a **pandemia** afetou a vacinação contra outras doenças?

    -   Ou a cobertura vacinal já estava caindo **antes mesmo da pandemia**?

-   **Comparações**:

    -   Qual seria a média de vacinação contra uma doença x para o continente y e onde seus países de escolha estão? (Dica: use `group_by()` e `summarize()`).

**Alguns conselhos:**

-   **Explore e leia os códigos do tutorial atentamente**. Tente entender o que cada linha de código faz.

-   Pense **quais variáveis** você quer analisar:

    -   É uma variável **numérica** ou **categórica**?

    -   O gráfico que você quer analisar combina **duas variáveis numéricas** (anos e cobertura vacinal) ou **uma variável categórica** (países) e outra **numérica** (cobertura vacinal)?

    -   A variável numérica é **temporal**? Por exemplo, você vai usar uma **série temporal** (2010, 2011, 2012...) ou somente a **média** de um período (2010 a 2020)?

        -   Caso use todos os anos em uma **série temporal**, recomendo usar um gráfico de **linhas**, onde o eixo x representa os anos e o eixo y, a cobertura vacinal ou numero de mortes.

        -   Agora, caso analise as **médias ou medianas de um período**, um gráfico de **colunas** é recomendado, onde o **eixo x é um ano e o y, o número de mortes ou cobertura vacinal.**

    -   **Para entender melhor os tipos de gráficos que você pode utilizar**, entre no [Data to viz](https://www.data-to-viz.com/). Ele te guiará como seguir a partir das variáveis que você está trabalhando.

    -   Caso queira gerar outros tipos de gráficos, use diferentes geometrias e consulte o (R graph gallery)[<https://r-graph-gallery.com/>].

-   Use o **esquisse** sempre para facilitar as análises iniciais. Os códigos podem ser complicados à primeira vista, mas o esquisse está aí para auxiliar nesse primeiro contato.

-   **Use o ChatGPT.** O ChatGPT é uma ferramenta extremamente útil para a sua evolução na programação e você precisa aprender a usá-lo e a fazer perguntas corretas. 80% das vezes ele dá respostas perfeitas. Você pode usá-lo para explicar, consertar e criar códigos!

    -   Copie e cole um bloco de código e peça para ele **explicar** cada linha e função.

    -   Deu algum **erro** no código? Manda pra ele também o código e o erro que aparece no console.

    -   Quer fazer algo **específico** e pontual no código? Manda pro ChatGPT!

-   **Envie suas dúvidas no grupo de Whatsapp**. Caso seja necessário, marque uma monitoria gratuita comigo.

